//Backup from: jan 23, 2019 2:45:30
//SET UP EVERYTHING
const Discord = require('discord.js');
const Music = require('discord.js-musicbot-addon');
const client = new Discord.Client();
const config = require('./config.json');
const fs = require('fs');
const log = config.log
const Canvas = require('canvas')
const snekfetch = require('snekfetch');
const version = require('./package.json');
const moment = require("moment");
const stats = require('systeminformation');
// ihack2712: edit, added a http server.
const Express = require('express');
const App  = Express()
let mlog = config.masterlog
let blog = config.botlog
let BTLog = '521748473247170625'
let meepLog =  '533073861516984351'
let prefix = config.prefix
let dmlog = config.dmlog
const backgrounds = ['']
//starts server and makes the website working
App.use(Express.static(__dirname + '/views'))
App.listen(3000, () => console.log('Server running on port 3000'))
//SET UP EVERYTHING
//sets up the dynamic command system
client.commands = new Discord.Collection();

const commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));
for (const file of commandFiles) {
    const command = require(`./commands/${file}`);
    client.commands.set(command.name, command);
}
const applyText = (canvas, text) => {
    const ctx = canvas.getContext('2d');
    let fontSize = 70;
    do {
        ctx.font = `${fontSize -= 10}px sans-serif`;
    } while (ctx.measureText(text).width > canvas.width - 300);
    return ctx.font;
};


//EVENTS
//runs when message is deleted
client.on("messageDelete", messageDelete => {
  let ctime = client.readyTimestamp + client.uptime - messageDelete.createdTimestamp
  let channel
  if (messageDelete.channel.type == 'dm') {let channel = 'a dm'}
    if (messageDelete.channel.type == 'group') {let channel = 'a group dm'}
if (messageDelete.channel.type == 'text'){
channel = `#${messageDelete.channel.name} (${messageDelete.channel.id}) in ${messageDelete.guild.name}`}
if (ctime <= 1000) {
  console.log(`A message by ${messageDelete.author.tag}(${messageDelete.author.id}) in ${channel} got deleted but it was ignored because the message was deleted in ${ctime}ms!
Message: ${messageDelete.content}`)
}
  else{
    if(messageDelete.author.bot) { console.log(`A message by ${messageDelete.author.tag}(${messageDelete.author.id}) in ${channel} got deleted but it was ignored because the message was created by a bot. It was alive for ${Math.round(ctime/1000)}s!
Message: ${messageDelete.content}`)}
    else{
const embed = new Discord.RichEmbed().setTitle('Message Deleted!').setDescription(`Message:
${messageDelete.content}`).addField(`Message Details:`, `Message by ${messageDelete.author.tag}(${messageDelete.author.id}) in ${channel} got deleted`).setColor('RED').setTimestamp().setFooter(`The Message was alive for ${Math.round(ctime /1000)}sec`).setThumbnail('https://cdn.discordapp.com/attachments/519547869909483568/520415850784751619/latest.png');
 client.channels.get(mlog).send(embed)
      if(messageDelete.guild.id == '519323312195633152'){
client.channels.get(meepLog).send(embed)}
      if(messageDelete.channel.type == 'text' && messageDelete.guild.id == 519997113648676879) {
      client.channels.get(BTLog).send(embed)}
}}});
client.on("messageDeleteBulk", BulkMessageDelete => {
  let message = BulkMessageDelete.first
  console.log(BulkMessageDelete)
  const embed = new Discord.RichEmbed().setTitle('Bulk Messages Deleted!').setDescription(`Messages Deleted: ${BulkMessageDelete.size}`).setColor('RED').setTimestamp().addField(`Message Details:`, `Messages in ${message.channel.name} (${message.channel.id}) got deleted in server ${message.guild.name} (${message.guild.id})`).setThumbnail('https://cdn.discordapp.com/attachments/519547869909483568/520415850784751619/latest.png')
  client.channels.get(mlog).send(embed)
  console.log(BulkMessageDelete)
  if(message.guild.id == '519323312195633152'){
client.channels.get(meepLog).send(embed)}
  
  if(BulkMessageDelete.channel.type == 'text' && BulkMessageDelete.guild.id == 519997113648676879) {
      client.channels.get(BTLog).send(embed)}
})
//runs when message is edited
client.on('messageUpdate', (oldMessage, newMessage) => {
  if(newMessage.author.id === client.user.id) return
  let ctime = client.readyTimestamp + client.uptime - oldMessage.createdTimestamp
  let channel
  if (newMessage.channel.name == undefined){
    if (newMessage.channel.type == 'dm') {channel = 'a dm'}
   else {channel = 'a group dm'}
  }  else
  {channel = `#${newMessage.channel.name} (${newMessage.channel.id}) in ${newMessage.guild.name}`}
  let server = newMessage.guild.id
if (ctime <= 1000) return;
  if(newMessage != ''){
  if(oldMessage.content === newMessage.content) return console.log(`A message was edited but was ignored because the Old Message = New Message. The message is:
${oldMessage.content}`)
   const embed = new Discord.RichEmbed().setTitle('Message Editied!').setDescription(`New Message:
${newMessage.content}`).addField('Old Message:', `${oldMessage.content}`).addField(`Message Details:`, `Message by ${newMessage.author.tag}(${newMessage.author.id}) in ${channel} was edited`).setColor('BLUE').setTimestamp().setFooter(`The Message was unchanged for ${Math.round(ctime / 1000)}sec`).setThumbnail('https://images-ext-1.discordapp.net/external/719r1Osmo7wivrqgwv5HQyU23uiOME3U4l7ApOzY7YQ/https/i.imgur.com/1cdcq2H.png');
 client.channels.get(mlog).send(embed)
if(server == '519323312195633152'){
client.channels.get(meepLog).send(embed)}
    if(oldMessage.channel.type == 'text' && oldMessage.guild.id == 519997113648676879) {
      client.channels.get(BTLog).send(embed)
    }
}});
//Runs when a member leaves
client.on('guildMemberRemove', async member => {
    const channel = member.guild.channels.find(ch => ch.name === 'welcome-and-goodbye');
    if (!channel) return;

    const canvas = Canvas.createCanvas(700, 250);
    const ctx = canvas.getContext('2d');

    const background = await Canvas.loadImage('https://cdn.glitch.com/0f219cf6-8874-4596-b103-fe60b57e709f%2Fwallpaper.jpg?1544540642640');
    ctx.drawImage(background, 0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = '#74037b';
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // Slightly smaller text placed above the member's display name
    ctx.font = '28px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Goodbye. We will miss you,', canvas.width / 2.5, canvas.height / 3.5);

    // Add an exclamation point here and below
    ctx.font = applyText(canvas, `${member.displayName}!`);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`${member.displayName}!`, canvas.width / 2.5, canvas.height / 1.8);

    ctx.beginPath();
    ctx.arc(125, 125, 100, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.clip();

    const { body: buffer } = await snekfetch.get(member.user.displayAvatarURL);
    const avatar = await Canvas.loadImage(buffer);
    ctx.drawImage(avatar, 25, 25, 200, 200);

    const attachment = new Discord.Attachment(canvas.toBuffer(), 'welcome-image.png');

    channel.send(`${member.user.tag} just left... Now there's only ${member.guild.members.size} MEEPs...`, attachment);
});
client.on('guildMemberAdd', async member => {
    const channel = member.guild.channels.find(ch => ch.name === 'welcome-and-goodbye');
    if (!channel) return;

    const canvas = Canvas.createCanvas(700, 250);
    const ctx = canvas.getContext('2d');

    const background = await Canvas.loadImage('https://cdn.glitch.com/0f219cf6-8874-4596-b103-fe60b57e709f%2Fwallpaper.jpg?1544540642640');
    ctx.drawImage(background, 0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = '#74037b';
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // Slightly smaller text placed above the member's display name
    ctx.font = '28px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`Welcome to the server,`, canvas.width / 2.5, canvas.height / 3.5);

    // Add an exclamation point here and below
    ctx.font = applyText(canvas, `${member.displayName}!`);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`${member.displayName}!`, canvas.width / 2.5, canvas.height / 1.8);

    ctx.beginPath();
    ctx.arc(125, 125, 100, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.clip();

    const { body: buffer } = await snekfetch.get(member.user.displayAvatarURL);
    const avatar = await Canvas.loadImage(buffer);
    ctx.drawImage(avatar, 25, 25, 200, 200);

    const attachment = new Discord.Attachment(canvas.toBuffer(), 'welcome-image.png');

    channel.send(`Hey <@${member.user.id}>, you are the ${member.guild.members.size}th MEEP on this server.`, attachment);
});

//starts the musicbot-addon client
Music.start(client, {
  botPrefix: prefix,
  prefix: prefix,
  maxQueueSize: "100",
  disableLoop: true,
  ownerOverMember: true,
  botOwner: '517371142508380170',
  youtubeKey: process.env.YOUTUBE,
  anyoneCanSkip: false,
  botAdmins: ["216371391358959626", "517371142508380170", "409844605614424074", "31297498587647181"],
  logging: false,
  anyonecanadjust: false,
  AnyoneCanLeave: false,
  requesterName: true,
  enableQueueStat: true,
  enableAliveMessage: true,
  defVolume: 200,
  checkQueues: true,
  musicPresence: false,
  insertMusic: true,
 help:{
    enabled: true,
    name: "mhelp"
},
  leave:{
    enabled: true,
    name: "leave",
    alt: ["lve", "leev", "begone"]
}});
//EVENTS

//COMMANDS
//runs when received a message and runs the command
client.on('message', message => {
  
  //eliminates useless messages, bot, dm, group dm, no prefix, only owner's id
  if (message.author.bot) return;
  
  //sends dm messages to the log
  if (message.channel.type === 'dm'){ 
  const embed = new Discord.RichEmbed().setAuthor(`${message.author.username}:`, message.author.avatarURL)
  .setDescription(message.content)
  .setTimestamp()
  if (client.channels.get(dmlog).topic === message.author.id){
  embed.setFooter(message.author.id+ " (Current User)")}
    else{
  embed.setFooter(message.author.id)}
  client.channels.get(dmlog).send(embed)}
  
  //Sends messages sent in dmlog to a dm.
  if (message.channel.id === dmlog && !message.content.startsWith(prefix)){
try {var dmmessage = message.content
const embed = new Discord.RichEmbed().setAuthor(`${message.author.username}:`, message.author.avatarURL)
  .setDescription(message.content)
  .setTimestamp()
let user = client.users.get(client.channels.get(dmlog).topic)
user.send(embed);
     const embed2 = new Discord.RichEmbed().setAuthor(`${message.author.username}:`, message.author.avatarURL)
  .setDescription(message.content)
  .setTimestamp()
.setFooter(`Message sent to ${user.tag} (${user.id})`, user.avatarURL)
     message.channel.send(`Message Sent:`, embed2)
}
                          catch (error) { console.error(error)
message.channel.send('Their was an error sending a dm to the user' + `
error: 
\`\`\`xl
${error}
\`\`\``)}}
///////////////////////////////////
////////////Commands//////////////
/////////////////////////////////
  if (message.content.indexOf(config.prefix) !== 0) return;
  //splits up the message prefix(removed), command, extra stuff(1,2,3)
  var args = message.content.slice(config.prefix.length).trim().split(/ +/g);
  //makes 'em small letters
  var commandName = args.shift().toLowerCase();
  //checks if command is valid
  if (!client.commands.has(commandName)) return;
  let isOwner 
  if(message.author.id == config.ownerId || message.author.id == config.chicken) {isOwner = true}
  else {isOwner = false}
  try {
    var command = client.commands.get(commandName)
    
    if(command.guildOnly && message.channel.type === 'dm') return message.channel.send('This command is server only, please run this command on server.');
    
    if(command.allow === 'botowner') {if(!isOwner) return message.channel.send('<:owner:537682898795626522>This command is bot owner only');}
    
    if(command.allow === 'serverowner' && message.author.id !== message.guild.owner.id) {if(message.author.id !== config.ownerId && message.author.id !== config.chicken) {return message.channel.send('This command is server owner only')}}
    
    if(command.allow === 'admin') {if(!message.member.hasPermission('MANAGE_GUILD', false, true, true) && !isOwner){return message.channel.send('This command is server admin only')}}
    command.execute(message, args, client, Discord, config, log, Music, fs, moment, dmlog);
}
catch (error) {
  //catches error sends it to log and to the command author
    console.error(error);
  var largs = args.join(" ")
  
  const embed = new Discord.RichEmbed().addField('<a:WeeWoo:525000522932027393>**__ERROR__**<a:WeeWoo:525000522932027393>', `Something went wrong while trying to execute that command. Follow the steps bellow to see if that fixes you issue:`)
  .addField('Step 1', 'Make sure that you provided arguments that are proper. You can check what arguments are needed in the ' + prefix + 'help command (When I get to making it).')
  .addField('Step 2', 'Make sure the bot has the proper access to do that command.')
  .addField('Step 3', `Finally if that doesn\'t work send me (<@${client.user.id}>) a message explaining the issue with the error message below and I will send it for you to get help. It also could be I have an issue with my code and hasen\'t been fixed it yet.`)
  .addField('Error message:', `\`\`\` ${error}\`\`\``)
  .setColor('RED')
  .setTimestamp()
  .setFooter(`${client.user.username} error message`)  
  const bembed = new Discord.RichEmbed().addField('<a:WeeWoo:525000522932027393>**__ERROR__**<a:WeeWoo:525000522932027393>', `OOF something went wrong.`)
  if (largs.length == 0) {bembed.addField('Args:', `none`)} else {bembed.addField('Args:', largs)}
  if (message.channel.type == 'text') {bembed.addField('Details:', `\`${message.author.tag}\` (\`${message.author.id}\`) got an error while trying to exexute the command \`${commandName}\` in server \`${message.guild.name}\` (\`${message.guild.id}\`) in the channel \`${message.channel.name}\`(\`${message.channel.id}\`)`)}
  else {bembed.addField('Details:', `\`${message.author.tag}\` (\`${message.author.id}\`) got an error while trying to exexute the command \`${commandName}\` in a dm`)}
  bembed.addField('Error message:', `\`\`\` ${error}\`\`\``)
  .setColor('RED')
  .setTimestamp()
  .setFooter(`Error message at`)
  client.channels.get(blog).send(`<@${config.ownerId}>`,bembed)  
  message.channel.send(embed);
  
}
});
//Commands





//STARTUP
client.on("ready", () => {
  console.log(`Bot has started, with ${client.users.size} users, in ${client.channels.size} channels of ${client.guilds.size} guilds.`);
client.user.setActivity(`With ${client.users.size} Friends`)
});


client.on('ready', () => {
/*
⢀⡴⠑⡄⠀⠀⠀⠀⠀⠀⠀⣀⣀⣤⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠸⡇⠀⠿⡀⠀⠀⠀⣀⡴⢿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠑⢄⣠⠾⠁⣀⣄⡈⠙⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⡀⠁⠀⠀⠈⠙⠛⠂⠈⣿⣿⣿⣿⣿⠿⡿⢿⣆⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⡾⣁⣀⠀⠴⠂⠙⣗⡀⠀⢻⣿⣿⠭⢤⣴⣦⣤⣹⠀⠀⠀⢀⢴⣶⣆
⠀⠀⢀⣾⣿⣿⣿⣷⣮⣽⣾⣿⣥⣴⣿⣿⡿⢂⠔⢚⡿⢿⣿⣦⣴⣾⠁⠸⣼⡿
⠀⢀⡞⠁⠙⠻⠿⠟⠉⠀⠛⢹⣿⣿⣿⣿⣿⣌⢤⣼⣿⣾⣿⡟⠉⠀⠀⠀⠀⠀
⠀⣾⣷⣶⠇⠀⠀⣤⣄⣀⡀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
⠀⠉⠈⠉⠀⠀⢦⡈⢻⣿⣿⣿⣶⣶⣶⣶⣤⣽⡹⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠉⠲⣽⡻⢿⣿⣿⣿⣿⣿⣿⣷⣜⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣷⣶⣮⣭⣽⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⠿⠿⠿⠛⠉
*/
  client.user.setActivity(choices[Math.floor(Math.random() * choices.length)])
  const embed = new Discord.RichEmbed().setTitle('Started up').setDescription('The Bot has just started').setTimestamp().setColor('RANDOM').setFooter(`${client.users.size} users, in ${client.channels.size} channels of ${client.guilds.size} guilds.`);
client.channels.get(blog).send(embed)
})
setInterval(function(){
      client.user.setActivity(choices[Math.floor(Math.random() * choices.length)]);
}, 60000);
const choices = ['With Cookies', 'With Cookie', `With Many Friends`, 'With Music', 'With MEEP of Faith']



client.login(process.env.TOKEN);
